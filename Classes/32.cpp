// Intializer List Constructor 

#include<iostream>

struct Point{

    double x;
    double y;

};

void print_point(const Point& p){
    std::cout<<"Point[ x :"<< p.x << ", y:"<<p.y<<"]";

}

int main()
{
    Point p1{22.4,65.4}; /* notice that this syntax is working.
Even if we didn't really set up any constructor to make this work. So how is this working?
Well, the compiler is generating an initializer list constructor behind your back, and that initializer
list constructor is taking the data here and using some magic to take the data and put that in this member variables.

And when you get to use your object, for example, by printing it out here, you're going to see that
the data here has ended up in this p1 object.

What the initializer list is going to do by default is to take the first thing here and use that to
initialize X like this.

And then it's going to take the second thing you specify here and use that to initialize y like this.
Or I should say this is what the initializer list constructor that is generated by the compiler is going
to do by default.*/

    print_point(p1);

}


/*for example, we want to use the first thing to initialize y and the second thing to initialize X.

Suppose you want that for your application.
You will need to set up your own initializer list constructor and we're going to do that in our struct here.

So the way we're going to do that, we're going to modify our structure a little bit and we're going to put in our member variables.*/


#include<iostream>
#include<cassert>
struct Point{

public:
   
   Point(std::initializer_list<double> list)
   {
    //static_assert( (list.size() == 2)); 

    /*We just want two elements in our initializer here. We can enforce this by using a staticassert. We already know that.
So what we can do, I think some of you are going to believe this can work is use a staticassert. But I hate to break to you.
This is not going to work as you see here, because the size of our list is the runtime thing.
It is something that is known at runtime when somebody initializes your object. So we can't use this at compile time.
It is not a constant expression.What we really need to use is something that works at runtime. So we're going to use an assert.*/
        
        assert(list.size() == 2); // If the size of the list is not 2, terminate the program with an error
    /*
    std::cout<<"Initalizer list constructor called"<<std::endl;
    std::cout<<"list size :" << list.size() <<std::endl;
    std::cout<<"first elt:" << *(list.begin()) <<std::endl;
     std::cout<<"first elt:" << *(list.begin()+1 ) <<std::endl;

     for(size_t i{};i<list.size();++i){
        std::cout << "elt["<<i<<"]:"<<*(list.begin()+i)<<std::endl;
     }

*/

                  y=*(list.begin());
                  x=*(list.begin() + 1);
   }

  void print_point() const {
    std::cout<<"Point[ x :"<< x << ", y:"<<y<<"]";

}
 
 private: 
    double x;
    double y;

};



int main()
{
    Point p1{22.4,65.4,5.9,6.8,4.3};
}