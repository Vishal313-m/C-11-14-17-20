/*FUNCTION TEMPLATE */

/*A template is a simple yet very powerful tool in C++. The simple idea is to pass the data type as a parameter so that we donâ€™t need to write the same code for different data types.
 For example, a software company may need to sort() for different data types. 
Rather than writing and maintaining multiple codes, we can write one sort() and pass the datatype as a parameter. */


/*We write a generic function that can be used for different data types. Examples of function templates are sort(), max(), min(), printArray(). */


/* - Function template are just blueprints . They're not real C++ code consumed by the compiler 
The compiler generates real C++ code by looking at the arguments you call your function template with */


/*The real c++ function generated by the compiler is called template instance */

/*A template instance will be reused when a similar function call (argument types) is issued . No duplicates are generated by the compiler */


#include<iostream>


template <typename T>
            this is template parameter 
             |    |
T maximum(T a , T b){
    return (a > b)? a : b; 
}


int main(){

    int x{5};
    int y{7};
                          this is template arguments 
                          |  |
    auto result = maximum(x,y);
    std::cout << "result : " << result << std::endl;
   
    return 0;
}

/*iT WILL CALL LIKE THIS 
int maximum<int>(int a, int b)
{
  return (a > b) ? a : b;
}
*/




/* 

- Function templates are just blueprints , they're not real function declaration and definition 

- Real function declarations and definitions ,aka templates instances are created when you call the function with arguments 

-If the template parameters are of the sane type (T,T), then the arguments you call the function with must also match ,otherwise you get a compiler error 

- Template instances won't always do what you want . A good example is when you call our maximum function with pointers. DISASTER!

- There are tools like cppinsights.io that can show you template instantiations . You can even use the debugger to infer that information from the activation record of  
a template function


- The arguments passed to a function  template must support the operations that are done in the body of the function 



*/


#include <iostream>

template <typename T>
T maximum(T a , T b){
    return (a > b)? a : b; 
}


int main(){

    int x{5};
    int y{7};

    int* p_x {&x};
    int* p_y{&y};

    auto result = maximum(p_x,p_y);
    std::cout << "result : " << *result << std::endl;
   
    return 0;
}

/*OUTPUT 

result: 5
*/